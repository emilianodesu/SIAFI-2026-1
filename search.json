[
  {
    "objectID": "IDS/1_1_fundamentals.html",
    "href": "IDS/1_1_fundamentals.html",
    "title": "1. Introduction to Data Science",
    "section": "",
    "text": "There’s a common joke that a data scientist is someone who knows more statistics than a computer scientist and more computer science than a statistician. (Whether or not it’s funny is up for debate.) Like all good jokes, though, it contains a kernel of truth. Some data scientists resemble statisticians who happen to code, while others look more like software engineers who dabble in analytics. Some are cutting-edge machine learning experts, while others focus primarily on business reporting or experimentation. There are PhDs with lengthy publication lists, and there are practitioners who have never opened an academic paper. In short, “data science” is notoriously hard to pin down, because almost any definition risks excluding someone who legitimately practices it.\nStill, the attempt at definition is worthwhile. At its core, we can say that data science is about extracting insight from messy, real-world data. The people who do this go by many titles—data scientist, data analyst, machine learning engineer, statistician, or business intelligence analyst. Even software engineers, researchers, and domain experts frequently find themselves doing the work of data science, whether or not it appears in their job description.\n\n\n\nVenn diagram showing overlap of skills in Data Science\n\n\nThe first diagram helps explain why data science is so difficult to define. It shows that data science sits at the intersection of computer science, mathematics & statistics, and domain knowledge. A successful data scientist combines all three: they need programming and software skills to manipulate data at scale, statistical and mathematical understanding to interpret results rigorously, and domain expertise to make those results meaningful in context. Add in machine learning, and you see how easily the field overlaps with multiple other disciplines.\n\n\n\nVenn diagram showing overlap of skills in Data Roles\n\n\nThe second diagram adds further clarity by mapping how different data-related roles emphasize different skill sets. Software engineers lean toward programming and system design, while data engineers focus on databases, pipelines, and scalable architectures. Data analysts center on reporting, visualization, and business understanding. Data scientists, meanwhile, sit in the overlap: they must balance coding ability, mathematical rigor, and communication skills to bridge technical work with actionable insight.\nThis overlap also underscores another key truth: data science is collaborative by nature. No one person masters the full breadth of skills in both diagrams. Data scientists usually work closely with engineers, analysts, domain experts, and business stakeholders. Technical proficiency alone is not enough—effective communication, critical thinking, and teamwork are equally essential to transform raw data into decisions that matter.\nIn this sense, data science is best seen not as a rigid job title, but as a mode of problem-solving that blends disciplines. The diversity of backgrounds among practitioners isn’t a weakness—it’s the very thing that makes the field so dynamic and impactful.\n\n\n\nThe data science process is an iterative and interdisciplinary workflow that transforms raw data into actionable knowledge. While the exact steps may vary depending on the project, industry, or team, the process generally includes the following key stages:\n\nProblem Definition: The process begins with a clear understanding of the problem to be solved or the question to be answered. This step often requires close collaboration with domain experts and stakeholders to ensure the problem is framed in a way that is both meaningful and solvable with data. A poorly defined problem can derail the entire process, making this stage critical.\nData Collection: Relevant data must then be gathered from diverse sources, which may include relational databases, APIs, web scraping, sensors, surveys, or third-party datasets. At this stage, considerations such as data accessibility, privacy, and quality play a major role in determining the project’s feasibility.\nData Cleaning and Preprocessing: Raw data is rarely analysis-ready. This step involves addressing missing values, correcting inconsistencies, removing duplicates, and transforming variables into usable formats. Depending on the project, preprocessing may also involve scaling, normalization, text parsing, or image transformation. High-quality preprocessing is essential, since poor data hygiene undermines all subsequent stages.\nExploratory Data Analysis (EDA): Before formal modeling, data scientists perform EDA to uncover structure, detect anomalies, visualize distributions, and generate initial hypotheses. This step combines statistical methods, visualization tools, and domain knowledge to shape an intuitive understanding of the dataset and guide later decisions about modeling.\nFeature Engineering: Raw data rarely contains all the information needed for predictive modeling. Data scientists therefore create new variables or transform existing ones to capture relevant patterns. Examples include aggregating time-series signals, encoding categorical variables, or constructing interaction terms. Good feature engineering often determines whether a model succeeds or fails.\nModel Selection and Training: With features prepared, data scientists select suitable algorithms based on the problem type (classification, regression, clustering, etc.), the data structure, and performance trade-offs. The chosen models are then trained on the dataset, often using cross-validation to tune hyperparameters and prevent overfitting.\nModel Evaluation: Trained models must be rigorously evaluated using appropriate metrics, such as accuracy, precision, recall, F1-score, ROC-AUC, or mean squared error, depending on the task. Evaluation also includes robustness testing, fairness assessments, and comparisons with baseline methods to ensure the model adds genuine value.\nModel Deployment: Once validated, the model is deployed into a production environment where it can generate predictions on new, unseen data. Deployment may involve integrating the model into applications, dashboards, or automated decision systems, often requiring collaboration with software engineers and DevOps teams.\nMonitoring and Maintenance: The data science process does not end with deployment. Models degrade over time due to changing data distributions, user behavior, or external factors—a phenomenon known as data drift. Continuous monitoring, retraining, and updating ensure the model remains reliable and relevant.\n\nThis cycle is iterative rather than strictly linear. Insights from later stages (such as poor model performance) often lead to revisiting earlier steps (such as redefining features or collecting additional data). Just as the diagrams showed, successful data science requires more than technical execution: it depends on problem framing, communication, domain expertise, and collaboration across multiple roles."
  },
  {
    "objectID": "IDS/1_1_fundamentals.html#basic-concepts-and-definitions",
    "href": "IDS/1_1_fundamentals.html#basic-concepts-and-definitions",
    "title": "1. Introduction to Data Science",
    "section": "",
    "text": "There’s a common joke that a data scientist is someone who knows more statistics than a computer scientist and more computer science than a statistician. (Whether or not it’s funny is up for debate.) Like all good jokes, though, it contains a kernel of truth. Some data scientists resemble statisticians who happen to code, while others look more like software engineers who dabble in analytics. Some are cutting-edge machine learning experts, while others focus primarily on business reporting or experimentation. There are PhDs with lengthy publication lists, and there are practitioners who have never opened an academic paper. In short, “data science” is notoriously hard to pin down, because almost any definition risks excluding someone who legitimately practices it.\nStill, the attempt at definition is worthwhile. At its core, we can say that data science is about extracting insight from messy, real-world data. The people who do this go by many titles—data scientist, data analyst, machine learning engineer, statistician, or business intelligence analyst. Even software engineers, researchers, and domain experts frequently find themselves doing the work of data science, whether or not it appears in their job description.\n\n\n\nVenn diagram showing overlap of skills in Data Science\n\n\nThe first diagram helps explain why data science is so difficult to define. It shows that data science sits at the intersection of computer science, mathematics & statistics, and domain knowledge. A successful data scientist combines all three: they need programming and software skills to manipulate data at scale, statistical and mathematical understanding to interpret results rigorously, and domain expertise to make those results meaningful in context. Add in machine learning, and you see how easily the field overlaps with multiple other disciplines.\n\n\n\nVenn diagram showing overlap of skills in Data Roles\n\n\nThe second diagram adds further clarity by mapping how different data-related roles emphasize different skill sets. Software engineers lean toward programming and system design, while data engineers focus on databases, pipelines, and scalable architectures. Data analysts center on reporting, visualization, and business understanding. Data scientists, meanwhile, sit in the overlap: they must balance coding ability, mathematical rigor, and communication skills to bridge technical work with actionable insight.\nThis overlap also underscores another key truth: data science is collaborative by nature. No one person masters the full breadth of skills in both diagrams. Data scientists usually work closely with engineers, analysts, domain experts, and business stakeholders. Technical proficiency alone is not enough—effective communication, critical thinking, and teamwork are equally essential to transform raw data into decisions that matter.\nIn this sense, data science is best seen not as a rigid job title, but as a mode of problem-solving that blends disciplines. The diversity of backgrounds among practitioners isn’t a weakness—it’s the very thing that makes the field so dynamic and impactful.\n\n\n\nThe data science process is an iterative and interdisciplinary workflow that transforms raw data into actionable knowledge. While the exact steps may vary depending on the project, industry, or team, the process generally includes the following key stages:\n\nProblem Definition: The process begins with a clear understanding of the problem to be solved or the question to be answered. This step often requires close collaboration with domain experts and stakeholders to ensure the problem is framed in a way that is both meaningful and solvable with data. A poorly defined problem can derail the entire process, making this stage critical.\nData Collection: Relevant data must then be gathered from diverse sources, which may include relational databases, APIs, web scraping, sensors, surveys, or third-party datasets. At this stage, considerations such as data accessibility, privacy, and quality play a major role in determining the project’s feasibility.\nData Cleaning and Preprocessing: Raw data is rarely analysis-ready. This step involves addressing missing values, correcting inconsistencies, removing duplicates, and transforming variables into usable formats. Depending on the project, preprocessing may also involve scaling, normalization, text parsing, or image transformation. High-quality preprocessing is essential, since poor data hygiene undermines all subsequent stages.\nExploratory Data Analysis (EDA): Before formal modeling, data scientists perform EDA to uncover structure, detect anomalies, visualize distributions, and generate initial hypotheses. This step combines statistical methods, visualization tools, and domain knowledge to shape an intuitive understanding of the dataset and guide later decisions about modeling.\nFeature Engineering: Raw data rarely contains all the information needed for predictive modeling. Data scientists therefore create new variables or transform existing ones to capture relevant patterns. Examples include aggregating time-series signals, encoding categorical variables, or constructing interaction terms. Good feature engineering often determines whether a model succeeds or fails.\nModel Selection and Training: With features prepared, data scientists select suitable algorithms based on the problem type (classification, regression, clustering, etc.), the data structure, and performance trade-offs. The chosen models are then trained on the dataset, often using cross-validation to tune hyperparameters and prevent overfitting.\nModel Evaluation: Trained models must be rigorously evaluated using appropriate metrics, such as accuracy, precision, recall, F1-score, ROC-AUC, or mean squared error, depending on the task. Evaluation also includes robustness testing, fairness assessments, and comparisons with baseline methods to ensure the model adds genuine value.\nModel Deployment: Once validated, the model is deployed into a production environment where it can generate predictions on new, unseen data. Deployment may involve integrating the model into applications, dashboards, or automated decision systems, often requiring collaboration with software engineers and DevOps teams.\nMonitoring and Maintenance: The data science process does not end with deployment. Models degrade over time due to changing data distributions, user behavior, or external factors—a phenomenon known as data drift. Continuous monitoring, retraining, and updating ensure the model remains reliable and relevant.\n\nThis cycle is iterative rather than strictly linear. Insights from later stages (such as poor model performance) often lead to revisiting earlier steps (such as redefining features or collecting additional data). Just as the diagrams showed, successful data science requires more than technical execution: it depends on problem framing, communication, domain expertise, and collaboration across multiple roles."
  },
  {
    "objectID": "IDS/1_1_fundamentals.html#fundamentals-for-data-scientists",
    "href": "IDS/1_1_fundamentals.html#fundamentals-for-data-scientists",
    "title": "1. Introduction to Data Science",
    "section": "1.2 Fundamentals for Data Scientists",
    "text": "1.2 Fundamentals for Data Scientists\n\n1.2.1 Visualizing Data\nA fundamental part of the data scientist’s toolkit is data visualization. Although it is very easy to create visualizations, it’s much harder to produce good ones. There are two primary uses for data visualization: * To explore the data and find patterns, trends, and anomalies. * To communicate results to others.\nA wide variety of tools exist for visualizing data. We will be using matplotlib, which is a popular Python library for creating visualizations. It provides a wide range of tools and functions to create various types of plots and charts. To install Matplotlib, you can use pip, the Python package manager. Open your terminal or command prompt and run the following command:\npip install matplotlib\nWe will be using the matplotlib.pyplot module. In it’s simplest use, pyplot maintains an internal state in which you build up a visualization step by step. Once you’re done, you can save it with savefig or display it with show. For example, making simple plots is pretty simple:\n\n\nCode\nimport matplotlib.pyplot as plt\n\nyears = [1950,  1960,  1970,  1980,  1990,  2000,  2010]\ngdp = [300.2,  543.3,  1075.9,  2862.5,  5979.6,  10289.7,  14958.3]\n\n# create a line chart, years on x-axis, gdp on y-axis\nplt.plot(years,  gdp,  color='green',  marker='o',  linestyle='solid')\n\n# add a title\nplt.title(\"Nominal GDP\")\n\n# add a label to the y-axis\nplt.ylabel(\"Billions of $\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_gdp.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nMaking plots that look publication-quality good is more complicated. There are many ways you can customize your charts with, for example, axis labels, line styles, and point markers. Rather than attempt a comprehensive treatment of these options, we’ll just use (and call attention to) some of them in our examples. Although we won’t be using much of this functionality, matplotlib is capable of producing complicated plots within plots, sophisticated formatting, and interactive visualizations. Check out the matplotlib documentation if you want to go deeper.\n\nBar Charts\nA bar chart is a good choice when you want to show how some quantity varies among some discrete set of items. For instance, the next figure shows how many Academy Awards were won by each of a variety of movies:\n\n\nCode\nmovies = [\"Annie Hall\", \"Ben-Hur\", \"Casablanca\", \"Gandhi\", \"West Side Story\"]\nnum_oscars = [5, 11, 3, 8, 10]\n\n# plot bars with left x-coordinates [0, 1, 2, 3, 4], heights [num_oscars]\nplt.bar(range(len(movies)), num_oscars)\n\nplt.title(\"My Favorite Movies\")     # add a title\nplt.ylabel(\"# of Academy Awards\")   # label the y-axis\n\n# label x-axis with movie names at bar centers\nplt.xticks(range(len(movies)), movies)\n\n# save the plot as a PNG file\nplt.savefig('im/viz_movies.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nA bar chart can also be a good choice for plotting histograms of bucketed numeric values, as in the next figure , in order to visually explore how the values are distributed:\n\n\nCode\nfrom collections import Counter\ngrades = [83, 95, 91, 87, 70, 0, 85, 82, 100, 67, 73, 77, 0]\n\n# Bucket grades by decile, but put 100 in with the 90s\nhistogram = Counter(min(grade // 10 * 10, 90) for grade in grades)\n\nplt.bar([x + 5 for x in histogram.keys()],  # Shift bars right by 5\n        list(histogram.values()),           # Give each bar its correct height\n        10,                                 # Give each bar a width of 8\n        edgecolor=(0, 0, 0))                # Black edges for each bar\n\nplt.axis((-5, 105, 0, 5))                  # x-axis from -5 to 105,\n                                           # y-axis from 0 to 5\n\nplt.xticks([10 * i for i in range(11)])    # x-axis labels at 0, 10, ..., 100\nplt.xlabel(\"Decile\")\nplt.ylabel(\"# of Students\")\nplt.title(\"Distribution of Exam 1 Grades\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_grades.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nThe third argument to plt.bar specifies the bar width. Here we chose a width of 10, to fill the entire decile. We also shifted the bars right by 5, so that, for example, the “10” bar (which corresponds to the decile 10–20) would have its center at 15 and hence occupy the correct range. We also added a black edge to eacch bar to make them visually distinct.\nThe call to plt.axis indicates that we want the x-axis to range from –5 to 105 (just to leave a little space on the left and right), and that the y-axis should range from 0 to 5. And the call to plt.xticks puts x-axis labels at 0, 10, 20, …, 100. Be judicious when using plt.axis. When creating bar charts it is considered especially bad form for your y-axis not to start at 0, since this is an easy way to mislead people:\n\n\nCode\nmentions = [500, 505]\nyears = [2017, 2018]\n\nplt.bar(years, mentions, 0.8)\nplt.xticks(years)\nplt.ylabel(\"# of times I heard someone say 'data science'\")\n\n# if you don't do this, matplotlib will label the x-axis 0, 1\n# and then add a +2.013e3 off in the corner (bad matplotlib!)\nplt.ticklabel_format(useOffset=False)\n\n# misleading y-axis only shows the part above 500\nplt.axis((2016.5, 2018.5, 499, 506))\nplt.title(\"Look at the 'Huge' Increase!\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_misleading_y_axis.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nHere we use more sensible axes, and it looks far less impressive:\n\n\nCode\nplt.bar(years, mentions, 0.8)\nplt.xticks(years)\nplt.ylabel(\"# of times I heard someone say 'data science'\")\nplt.ticklabel_format(useOffset=False)\n\nplt.axis((2016.5, 2018.5, 0, 550))\nplt.title(\"Not So Huge Anymore\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_non_misleading_y_axis.png')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nLine Charts\nAs we saw already, we can make line charts using plt.plot. These are a good choice for showing trends:\n\n\nCode\nvariance = [1, 2, 4, 8, 16, 32, 64, 128, 256]\nbias_squared = [256, 128, 64, 32, 16, 8, 4, 2, 1]\ntotal_error = [x + y for x, y in zip(variance, bias_squared)]\nxs = [i for i, _ in enumerate(variance)]\n\n# We can make multiple calls to plt.plot\n# to show multiple series on the same chart\nplt.plot(xs, variance,     'g-',  label='variance')    # green solid line\nplt.plot(xs, bias_squared, 'r-.', label='bias^2')      # red dot-dashed line\nplt.plot(xs, total_error,  'b:',  label='total error')  # blue dotted line\n\n# Because we've assigned labels to each series,\n# we can get a legend for free (loc=9 means \"top center\")\nplt.legend(loc=9)\nplt.xlabel(\"model complexity\")\nplt.xticks([])\nplt.title(\"The Bias-Variance Tradeoff\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_line_chart.png')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nScatterplots\nA scatterplot is the right choice for visualizing the relationship between two paired sets of data. For example, the next visualization illustrates the relationship between the number of friends your users have and the number of minutes they spend on the site every day:\n\n\nCode\nfriends = [ 70,  65,  72,  63,  71,  64,  60,  64,  67]\nminutes = [175, 170, 205, 120, 220, 130, 105, 145, 190]\nlabels =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\nplt.scatter(friends, minutes)\n\n# label each point\nfor label, friend_count, minute_count in zip(labels, friends, minutes):\n    plt.annotate(label,\n        xy=(friend_count, minute_count), # Put the label with its point\n        xytext=(5, -5),                  # but slightly offset\n        textcoords='offset points')\n\nplt.title(\"Daily Minutes vs. Number of Friends\")\nplt.xlabel(\"# of friends\")\nplt.ylabel(\"daily minutes spent on the site\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_scatterplot.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nIf you’re scattering comparable variables, you might get a misleading picture if you let matplotlib choose the scale.\n\n\nCode\ntest_1_grades = [ 99, 90, 85, 97, 80]\ntest_2_grades = [100, 85, 60, 90, 70]\n\nplt.scatter(test_1_grades, test_2_grades)\nplt.title(\"Axes Aren't Comparable\")\nplt.xlabel(\"test 1 grade\")\nplt.ylabel(\"test 2 grade\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_scatterplot_axes_not_comparable.png')\nplt.show()\n\n\n\n\n\n\n\n\n\nIf we include a call to plt.axis(\"equal\"), the plot more accurately shows that most of the variation occurs on test 2.\n\n\nCode\ntest_1_grades = [99, 90, 85, 97, 80]\ntest_2_grades = [100, 85, 60, 90, 70]\n\nplt.scatter(test_1_grades, test_2_grades)\nplt.title(\"Axes Are Comparable\")\nplt.axis(\"equal\")\nplt.xlabel(\"test 1 grade\")\nplt.ylabel(\"test 2 grade\")\n\n# save the plot as a PNG file\nplt.savefig('im/viz_scatterplot_axes_comparable.png')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nFor Further Exploration\n\nMatplotlib Gallery will give you a good idea of the sorts of things you can do with matplotlib (and how to do them).\nSeaborn is a higher-level visualization library built on top of matplotlib that provides a more user-friendly interface and additional features for creating attractive and informative statistical graphics.\nAltair is a declarative statistical visualization library for Python. It allows you to create complex visualizations with concise and expressive code.\nPlotly is another popular visualization library that allows for interactive and web-based visualizations. It provides a wide range of chart types and customization options.\nD3.js is a JavaScript library for creating interactive and dynamic visualizations on the web. While it is not a Python library, it is widely used for data visualization and can be integrated with Python using libraries like Bokeh or Dash.\n\n\n\n\n1.2.2 Linear Algebra\n\nVectors\nA vector is a mathematical object that represents both magnitude (size) and direction. In data science, we think of vectors as ordered lists of numbers that can represent data points, features, or measurements. Geometrically, a vector can be visualized as an arrow pointing from the origin to a specific point in space.\nVectors are fundamental building blocks in linear algebra and essential for: - Storing and manipulating data - Representing features in machine learning - Performing mathematical operations on datasets - Computing distances and similarities between data points\nA vector has countless practical applications. In physics, a vector is often thought of as a direction and magnitude. In math, it is a direction and scale on an XY plane, kind of like a movement. In computer science, it is an array of numbers storing data. The computer science context is the one we will become the most familiar with as data science professionals.\nMathematical Notation:\nWe represent vectors using lowercase letters with arrows: \\(\\vec{v}\\), \\(\\vec{w}\\), or in column form:\n\\[\\vec{v} = \\begin{bmatrix} v_1 \\\\ v_2 \\\\ \\vdots \\\\ v_n \\end{bmatrix}\\]\nTypes of Vectors\nRow Vector: Numbers arranged horizontally \\[\\vec{v} = [v_1, v_2, v_3, ..., v_n]\\]\nColumn Vector: Numbers arranged vertically \\[\\vec{v} = \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ \\vdots \\\\ v_n \\end{bmatrix}\\]\nUnit Vector: A vector with magnitude (length) equal to 1\nZero Vector: A vector where all components are zero \\[\\vec{0} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}\\]\nTo emphasize again, the purpose of the vector is to visually represent a piece of data. If you have a data record for the square footage of a house 18,000 square feet and its valuation $260,000, we could express that as a vector [18000, 2600000], stepping 18,000 steps in the horizontal direction and 260,000 steps in the vertical direction.\nWe can declare a vector mathematically like this:\n\\(\\vec{v} = \\begin{bmatrix} 3 , 2 \\end{bmatrix}\\)\nWe can declare a vector using a simple Python collection, like a Python list:\n\n\nCode\nv = [3, 2]\nprint(v)\n\n\n[3, 2]\n\n\nHowever, when we start doing mathematical computations with vectors, especially when doing tasks like machine learning, we should probably use the numpy library as it is more efficient than plain Python. You can also use sympy to perform linear algebra operations; however, numpy is what you will likely use in practice so that is what we will mainly stick to. To declare a vector, you can use NumPy’s array() function and then can pass a collection of numbers to it\n\n\nCode\nimport numpy as np\n\n# Creating a basic 2D vector\nv = np.array([3, 3])\nprint(\"2D Vector:\")\nprint(f\"v = {v}\")\nprint(f\"Type: {type(v)}\")\nprint(f\"Shape: {v.shape}\")\nprint(f\"Dimension: {v.ndim}\")\n\n\n2D Vector:\nv = [3 3]\nType: &lt;class 'numpy.ndarray'&gt;\nShape: (2,)\nDimension: 1\n\n\nNote also vectors can exist on more than two dimensions. Next we declare a three- dimensional vector along axes \\(x\\), \\(y\\), and \\(z\\):\n\\(\\vec{v}  = \\begin{bmatrix} 4 , 1 , 2 \\end{bmatrix}\\)\nNaturally, we can express this three-dimensional vector in Python using three numeric values:\n\n\nCode\n# 3D vector\nv3d = np.array([4, 1, 2])\nprint(\"3D Vector:\")\nprint(f\"v3d = {v3d}\")\n\n\n3D Vector:\nv3d = [4 1 2]\n\n\nOr something like:\n\\(\\vec{v} = \\begin{bmatrix} 6 , 1 , 5 , 8 , 3 \\end{bmatrix}\\)\n\n\nCode\n# Higher dimensional vector (5D)\nv5d = np.array([6, 1, 5, 8, 3])\nprint(\"\\n5D Vector:\")\nprint(f\"v5d = {v5d}\")\n\n\n\n5D Vector:\nv5d = [6 1 5 8 3]\n\n\n\nVector properties and operations\n\n\nCode\n# Calculate vector magnitude (length)\nv = np.array([3, 4])\nmagnitude = np.linalg.norm(v)\nprint(f\"Vector v = {v}\")\nprint(f\"Magnitude of v = {magnitude}\")\n\n# Create unit vector (normalize)\nunit_v = v / magnitude\nprint(f\"Unit vector = {unit_v}\")\nprint(f\"Unit vector magnitude = {np.linalg.norm(unit_v)}\")\n\n# Zero vector\nzero_vector = np.zeros(3)\nprint(f\"Zero vector: {zero_vector}\")\n\n# Vector of ones\nones_vector = np.ones(4)\nprint(f\"Ones vector: {ones_vector}\")\n\n\nVector v = [3 4]\nMagnitude of v = 5.0\nUnit vector = [0.6 0.8]\nUnit vector magnitude = 1.0\nZero vector: [0. 0. 0.]\nOnes vector: [1. 1. 1. 1.]\n\n\n\n\nCode\n# Vector addition and subtraction\n\nv1 = np.array([2, 3, 1])\nv2 = np.array([1, -1, 4])\n\n# Addition\nv_sum = v1 + v2\nprint(f\"v1 = {v1}\")\nprint(f\"v2 = {v2}\")\nprint(f\"v1 + v2 = {v_sum}\")\n\n# Subtraction\nv_diff = v1 - v2\nprint(f\"v1 - v2 = {v_diff}\")\n\n# Element-wise operations\nv_mult = v1 * v2  # Element-wise multiplication\nprint(f\"v1 * v2 (element-wise) = {v_mult}\")\n\n\nv1 = [2 3 1]\nv2 = [ 1 -1  4]\nv1 + v2 = [3 2 5]\nv1 - v2 = [ 1  4 -3]\nv1 * v2 (element-wise) = [ 2 -3  4]\n\n\n\n\nCode\n# Scalar multiplication (scaling)\n\nv = np.array([2, -3, 1])\nscalar = 2.5\n\n# Scale the vector\nscaled_v = scalar * v\nprint(f\"Original vector: {v}\")\nprint(f\"Scalar: {scalar}\")\nprint(f\"Scaled vector: {scaled_v}\")\n\n# Scaling changes magnitude but not direction (unless scalar is negative)\nprint(f\"Original magnitude: {np.linalg.norm(v):.2f}\")\nprint(f\"Scaled magnitude: {np.linalg.norm(scaled_v):.2f}\")\nprint(f\"Magnitude ratio: {np.linalg.norm(scaled_v) / np.linalg.norm(v):.2f}\")\n\n\nOriginal vector: [ 2 -3  1]\nScalar: 2.5\nScaled vector: [ 5.  -7.5  2.5]\nOriginal magnitude: 3.74\nScaled magnitude: 9.35\nMagnitude ratio: 2.50\n\n\n\n\nCode\n# Dot product (scalar product)\n\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\n\n# Calculate dot product\ndot_product = np.dot(v1, v2)\nprint(f\"v1 = {v1}\")\nprint(f\"v2 = {v2}\")\nprint(f\"Dot product v1 · v2 = {dot_product}\")\n\n# Alternative syntax\ndot_product_alt = v1 @ v2  # Matrix multiplication operator\nprint(f\"Alternative syntax: v1 @ v2 = {dot_product_alt}\")\n\n# Geometric interpretation: dot product relates to angle between vectors\nangle_cos = dot_product / (np.linalg.norm(v1) * np.linalg.norm(v2))\nangle_rad = np.arccos(angle_cos)\nangle_deg = np.degrees(angle_rad)\nprint(f\"Angle between vectors: {angle_deg:.2f} degrees\")\n\n\nv1 = [1 2 3]\nv2 = [4 5 6]\nDot product v1 · v2 = 32\nAlternative syntax: v1 @ v2 = 32\nAngle between vectors: 12.93 degrees\n\n\n\n\nCode\n# Vector indexing and slicing\n\ndata = np.array([10, 20, 30, 40, 50, 60])\nprint(f\"Original vector: {data}\")\n\n# Access single elements\nprint(f\"First element: {data[0]}\")\nprint(f\"Last element: {data[-1]}\")\nprint(f\"Third element: {data[2]}\")\n\n# Slicing\nprint(f\"First three elements: {data[:3]}\")\nprint(f\"Last two elements: {data[-2:]}\")\nprint(f\"Middle elements: {data[2:4]}\")\nprint(f\"Every second element: {data[::2]}\")\n\n# Boolean indexing\nmask = data &gt; 30\nprint(f\"Elements greater than 30: {data[mask]}\")\n\n# Find indices where condition is true\nindices = np.where(data &gt; 30)\nprint(f\"Indices where data &gt; 30: {indices[0]}\")\n\n\nOriginal vector: [10 20 30 40 50 60]\nFirst element: 10\nLast element: 60\nThird element: 30\nFirst three elements: [10 20 30]\nLast two elements: [50 60]\nMiddle elements: [30 40]\nEvery second element: [10 30 50]\nElements greater than 30: [40 50 60]\nIndices where data &gt; 30: [3 4 5]\n\n\n\n\nCode\n# Creating special vectors\n\n# Range-based vectors\nrange_vector = np.arange(0, 10, 2)  # Start, stop, step\nprint(f\"Range vector: {range_vector}\")\n\n# Linearly spaced vectors\nlinear_space = np.linspace(0, 1, 5)  # Start, stop, number of points\nprint(f\"Linear space: {linear_space}\")\n\n# Random vectors\nnp.random.seed(42)  # For reproducible results\nrandom_vector = np.random.randint(1, 10, size=5)\nprint(f\"Random integers: {random_vector}\")\n\nrandom_normal = np.random.normal(0, 1, 5)  # Mean=0, std=1, size=5\nprint(f\"Random normal: {random_normal}\")\n\n# Vector from list\nlist_data = [1.5, 2.7, 3.1, 4.8, 5.2]\nvector_from_list = np.array(list_data)\nprint(f\"From list: {vector_from_list}\")\n\n\nRange vector: [0 2 4 6 8]\nLinear space: [0.   0.25 0.5  0.75 1.  ]\nRandom integers: [7 4 8 5 7]\nRandom normal: [-0.91682684 -0.12414718 -2.01096289 -0.49280342  0.39257975]\nFrom list: [1.5 2.7 3.1 4.8 5.2]\n\n\nManipulating Data Is Manipulating Vectors: Every data operation can be thought of in terms of vectors, even simple averages. Take scaling, for example. Let’s say we were trying to get the average house value and average square footage for an entire neighborhood. We would add the vectors together to combine their value and square footage respectively, giving us one giant vector containing both total value and total square footage. We then scale down the vector by dividing by the number of houses N , which really is multiplying by 1/ N . We now have a vector containing the average house value and average square footage.\n\n\nCode\n# Vector operations for data analysis\n\n# Sales data over 6 months\nsales_q1 = np.array([10000, 12000, 15000])  # Jan, Feb, Mar\nsales_q2 = np.array([18000, 20000, 22000])  # Apr, May, Jun\n\nprint(\"Sales Data:\")\nprint(f\"Q1 Sales: {sales_q1}\")\nprint(f\"Q2 Sales: {sales_q2}\")\n\n# Calculate quarterly growth\ngrowth = sales_q2 - sales_q1\nprint(f\"Monthly Growth: {growth}\")\n\n# Calculate growth percentage\ngrowth_percentage = (growth / sales_q1) * 100\nprint(f\"Growth Percentage: {growth_percentage}%\")\n\n# Total sales for each quarter\nq1_total = np.sum(sales_q1)\nq2_total = np.sum(sales_q2)\nprint(f\"\\nQ1 Total: ${q1_total:,}\")\nprint(f\"Q2 Total: ${q2_total:,}\")\n\n# Average monthly sales\nq1_avg = np.mean(sales_q1)\nq2_avg = np.mean(sales_q2)\nprint(f\"Q1 Average: ${q1_avg:,.0f}\")\nprint(f\"Q2 Average: ${q2_avg:,.0f}\")\n\n\nSales Data:\nQ1 Sales: [10000 12000 15000]\nQ2 Sales: [18000 20000 22000]\nMonthly Growth: [8000 8000 7000]\nGrowth Percentage: [80.         66.66666667 46.66666667]%\n\nQ1 Total: $37,000\nQ2 Total: $60,000\nQ1 Average: $12,333\nQ2 Average: $20,000\n\n\n\n\n\nMatrices\nA matrix is a rectangular array of numbers arranged in rows and columns. Matrices are fundamental structures in linear algebra and serve as powerful tools for representing and manipulating data in data science. Think of a matrix as a collection of vectors arranged side by side, or as a way to organize data in a tabular format.\nMathematically, we represent a matrix using capital letters like \\(A\\), \\(B\\), or \\(M\\). A matrix with \\(m\\) rows and \\(n\\) columns is called an \\(m \\times n\\) matrix:\n\\[A = \\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\cdots & a_{mn}\n\\end{bmatrix}\\]\nFor example, a \\(2 \\times 3\\) matrix looks like:\n\\[A = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6\n\\end{bmatrix}\\]\nIn data science, matrices are everywhere. A dataset with multiple features for multiple observations is essentially a matrix where each row represents an observation and each column represents a feature.\nTypes of Matrices\nSquare Matrix: A matrix where the number of rows equals the number of columns (\\(n \\times n\\)).\n\\[A = \\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\nIdentity Matrix: A special square matrix with 1s on the diagonal and 0s elsewhere. It’s the matrix equivalent of the number 1 in multiplication.\n\\[I = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\\]\nZero Matrix: A matrix where all elements are zero.\n\\[O = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix}\\]\nDiagonal Matrix: A square matrix where all non-diagonal elements are zero.\n\\[D = \\begin{bmatrix}\n3 & 0 & 0 \\\\\n0 & 5 & 0 \\\\\n0 & 0 & 2\n\\end{bmatrix}\\]\nLet’s see how to work with these matrices using NumPy:\n\n\nCode\n# Creating a basic matrix (2x3)\nA = np.array([[1, 2, 3],\n              [4, 5, 6]])\nprint(\"Matrix A:\")\nprint(A)\nprint(f\"Shape: {A.shape}\")\nprint(f\"Dimension: {A.ndim}\")\nprint(f\"Type: {type(A)}\")\n\n\nMatrix A:\n[[1 2 3]\n [4 5 6]]\nShape: (2, 3)\nDimension: 2\nType: &lt;class 'numpy.ndarray'&gt;\n\n\n\n\nCode\n# Creating a square matrix (3x3)\nB = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]])\nprint(\"Square Matrix B:\")\nprint(B)\nprint(f\"Shape: {B.shape}\")\n\n\nSquare Matrix B:\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\nShape: (3, 3)\n\n\n\n\nCode\n# Creating an identity matrix\nI = np.eye(3)  # 3x3 identity matrix\nprint(\"Identity Matrix:\")\nprint(I)\n\n\nIdentity Matrix:\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n\n\n\nCode\n# Creating a zero matrix\nzeros = np.zeros((2, 4))  # 2x4 zero matrix\nprint(\"Zero Matrix:\")\nprint(zeros)\n\n\nZero Matrix:\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n\n\n\n\nCode\n# Creating a diagonal matrix\ndiagonal_values = [3, 5, 2]\nD = np.diag(diagonal_values)\nprint(\"Diagonal Matrix:\")\nprint(D)\n\n\nDiagonal Matrix:\n[[3 0 0]\n [0 5 0]\n [0 0 2]]\n\n\nMatrix operations\n\n\nCode\n# Matrix addition (matrices must have the same dimensions)\nA1 = np.array([[1, 2], \n               [3, 4]])\nA2 = np.array([[5, 6], \n               [7, 8]])\n\nmatrix_sum = A1 + A2\nprint(\"Matrix Addition:\")\nprint(f\"A1 + A2 = \\n{matrix_sum}\")\n\n\nMatrix Addition:\nA1 + A2 = \n[[ 6  8]\n [10 12]]\n\n\n\n\nCode\n# Scalar multiplication\nscalar = 3\nscaled_matrix = scalar * A1\nprint(\"Scalar Multiplication:\")\nprint(f\"3 * A1 = \\n{scaled_matrix}\")\n\n\nScalar Multiplication:\n3 * A1 = \n[[ 3  6]\n [ 9 12]]\n\n\n\n\nCode\n# Matrix transpose (swap rows and columns)\noriginal = np.array([[1, 2, 3],\n                     [4, 5, 6]])\ntransposed = original.T  # or np.transpose(original)\nprint(\"Original Matrix:\")\nprint(original)\nprint(\"Transposed Matrix:\")\nprint(transposed)\n\n\nOriginal Matrix:\n[[1 2 3]\n [4 5 6]]\nTransposed Matrix:\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n\nCode\n# Accessing matrix elements\nmatrix = np.array([[10, 20, 30],\n                   [40, 50, 60],\n                   [70, 80, 90]])\n\nprint(\"Full matrix:\")\nprint(matrix)\nprint(f\"Element at row 1, column 2: {matrix[1, 2]}\")  # Remember: 0-indexed\nprint(f\"First row: {matrix[0, :]}\")\nprint(f\"Second column: {matrix[:, 1]}\")\nprint(f\"Submatrix (first 2x2): \\n{matrix[:2, :2]}\")\n\n\nFull matrix:\n[[10 20 30]\n [40 50 60]\n [70 80 90]]\nElement at row 1, column 2: 60\nFirst row: [10 20 30]\nSecond column: [20 50 80]\nSubmatrix (first 2x2): \n[[10 20]\n [40 50]]\n\n\n\n\nCode\n# Practical example: Student grades matrix\n# Rows represent students, columns represent subjects\ngrades = np.array([[85, 92, 78, 90],  # Student 1: Math, Science, English, History\n                   [79, 85, 88, 92],  # Student 2\n                   [92, 88, 85, 87],  # Student 3\n                   [88, 90, 92, 85]]) # Student 4\n\nsubjects = ['Math', 'Science', 'English', 'History']\nstudents = ['Alice', 'Bob', 'Charlie', 'Diana']\n\nprint(\"Student Grades Matrix:\")\nprint(grades)\nprint(f\"Shape: {grades.shape} (4 students, 4 subjects)\")\n\n# Calculate average grade per student\nstudent_averages = np.mean(grades, axis=1)  # axis=1 means across columns\nprint(\"\\nAverage grades per student:\")\nfor i, student in enumerate(students):\n    print(f\"{student}: {student_averages[i]:.2f}\")\n\n# Calculate average grade per subject\nsubject_averages = np.mean(grades, axis=0)  # axis=0 means across rows\nprint(\"\\nAverage grades per subject:\")\nfor i, subject in enumerate(subjects):\n    print(f\"{subject}: {subject_averages[i]:.2f}\")\n\n\nStudent Grades Matrix:\n[[85 92 78 90]\n [79 85 88 92]\n [92 88 85 87]\n [88 90 92 85]]\nShape: (4, 4) (4 students, 4 subjects)\n\nAverage grades per student:\nAlice: 86.25\nBob: 86.00\nCharlie: 88.00\nDiana: 88.75\n\nAverage grades per subject:\nMath: 86.00\nScience: 88.75\nEnglish: 85.75\nHistory: 88.50\n\n\n\n\nDeterminants\nA determinant is a scalar value that can be calculated from a square matrix. It provides important information about the matrix’s properties and has numerous applications in linear algebra, geometry, and data science. The determinant tells us whether a matrix is invertible, how it transforms areas and volumes, and is crucial for solving systems of linear equations.\nMathematical Notation: For a square matrix \\(A\\), we denote its determinant as \\(\\det(A)\\) or \\(|A|\\).\nKey Properties of Determinants: - Only square matrices have determinants - If \\(\\det(A) = 0\\), the matrix is singular (non-invertible) - If \\(\\det(A) \\neq 0\\), the matrix is invertible - The determinant represents the scaling factor of the linear transformation - For a 2D matrix, it represents the area scaling factor; for 3D, the volume scaling factor\nGeometric Interpretation: The absolute value of the determinant tells us how much the matrix scales areas (in 2D) or volumes (in 3D). A negative determinant indicates that the transformation reverses orientation.\nApplications in Data Science: - Checking if a system of equations has a unique solution - Computing matrix inverses - Principal Component Analysis (PCA) - Measuring multicollinearity in regression analysis - Volume calculations in high-dimensional spaces\n\n\nCode\n# Calculate determinant of a 2x2 matrix\nA_2x2 = np.array([[1, 2],\n                  [2, 5]])\n\ndet_A = np.linalg.det(A_2x2)\nprint(\"2x2 Matrix:\")\nprint(A_2x2)\nprint(f\"Determinant: {det_A}\")\n\n# Manual calculation for 2x2: ad - bc\nmanual_det = A_2x2[0,0] * A_2x2[1,1] - A_2x2[0,1] * A_2x2[1,0]\nprint(f\"Manual calculation: {manual_det}\")\n\n\n2x2 Matrix:\n[[1 2]\n [2 5]]\nDeterminant: 1.0\nManual calculation: 1\n\n\n\n\nCode\n# Calculate determinant of a 3x3 matrix\nA_3x3 = np.array([[1, 2, 3],\n                  [0, 1, 4],\n                  [5, 6, 0]])\n\ndet_A_3x3 = np.linalg.det(A_3x3)\nprint(\"3x3 Matrix:\")\nprint(A_3x3)\nprint(f\"Determinant: {det_A_3x3:.2f}\")\n\n\n3x3 Matrix:\n[[1 2 3]\n [0 1 4]\n [5 6 0]]\nDeterminant: 1.00\n\n\n\n\nCode\n# Special matrices and their determinants\n\n# Identity matrix - determinant is always 1\nI = np.eye(3)\nprint(\"Identity Matrix:\")\nprint(I)\nprint(f\"Determinant: {np.linalg.det(I)}\")\n\n# Diagonal matrix - determinant is product of diagonal elements\nD = np.diag([4, 4, 2])\nprint(\"\\nDiagonal Matrix:\")\nprint(D)\nprint(f\"Determinant: {np.linalg.det(D)}\")\nprint(f\"Product of diagonal elements: {4 * 4 * 2}\")\n\n\nIdentity Matrix:\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\nDeterminant: 1.0\n\nDiagonal Matrix:\n[[4 0 0]\n [0 4 0]\n [0 0 2]]\nDeterminant: 32.0\nProduct of diagonal elements: 32\n\n\n\n\nCode\n# Singular matrix (determinant = 0)\nsingular_matrix = np.array([[1, 2, 3],\n                           [2, 4, 6],\n                           [1, 1, 1]])\n\ndet_singular = np.linalg.det(singular_matrix)\nprint(\"Singular Matrix (rows are linearly dependent):\")\nprint(singular_matrix)\nprint(f\"Determinant: {det_singular:.10f}\")  # Should be very close to 0\n\n# This matrix is not invertible\ntry:\n    inverse = np.linalg.inv(singular_matrix)\nexcept np.linalg.LinAlgError as e:\n    print(f\"Cannot invert: {e}\")\n\n\nSingular Matrix (rows are linearly dependent):\n[[1 2 3]\n [2 4 6]\n [1 1 1]]\nDeterminant: 0.0000000000\nCannot invert: Singular matrix\n\n\n\n\nCode\n# Properties of determinants\n\nA = np.array([[2, 1],\n              [3, 4]])\n\nB = np.array([[1, 2],\n              [0, 3]])\n\nprint(\"Matrix A:\")\nprint(A)\nprint(f\"det(A) = {np.linalg.det(A)}\")\n\nprint(\"\\nMatrix B:\")\nprint(B)\nprint(f\"det(B) = {np.linalg.det(B)}\")\n\n# Property: det(AB) = det(A) * det(B)\nAB = A @ B\nprint(f\"\\nA @ B:\")\nprint(AB)\nprint(f\"det(AB) = {np.linalg.det(AB)}\")\nprint(f\"det(A) * det(B) = {np.linalg.det(A) * np.linalg.det(B)}\")\n\n# Property: det(A^T) = det(A)\nA_transpose = A.T\nprint(f\"\\ndet(A^T) = {np.linalg.det(A_transpose)}\")\nprint(f\"det(A) = {np.linalg.det(A)}\")\n\n\nMatrix A:\n[[2 1]\n [3 4]]\ndet(A) = 5.000000000000001\n\nMatrix B:\n[[1 2]\n [0 3]]\ndet(B) = 3.0000000000000004\n\nA @ B:\n[[ 2  7]\n [ 3 18]]\ndet(AB) = 15.0\ndet(A) * det(B) = 15.000000000000005\n\ndet(A^T) = 5.000000000000001\ndet(A) = 5.000000000000001\n\n\n\n\nCode\n# Practical example: Checking system solvability\n\n# System of equations: \n# 2x + 3y = 7\n# 4x + 6y = 14\n\n# Coefficient matrix\ncoeff_matrix = np.array([[2, 3],\n                        [4, 6]])\n\n# Constants vector\nconstants = np.array([7, 14])\n\ndet_coeff = np.linalg.det(coeff_matrix)\nprint(\"Coefficient Matrix:\")\nprint(coeff_matrix)\nprint(f\"Determinant: {det_coeff}\")\n\nif abs(det_coeff) &lt; 1e-10:  # Close to zero\n    print(\"System has no unique solution (infinite solutions or no solution)\")\n    # Check if system is consistent\n    augmented = np.column_stack([coeff_matrix, constants])\n    rank_coeff = np.linalg.matrix_rank(coeff_matrix)\n    rank_augmented = np.linalg.matrix_rank(augmented)\n    \n    if rank_coeff == rank_augmented:\n        print(\"System has infinite solutions\")\n    else:\n        print(\"System has no solution\")\nelse:\n    print(\"System has a unique solution\")\n    solution = np.linalg.solve(coeff_matrix, constants)\n    print(f\"Solution: x = {solution[0]}, y = {solution[1]}\")\n\n\nCoefficient Matrix:\n[[2 3]\n [4 6]]\nDeterminant: 0.0\nSystem has no unique solution (infinite solutions or no solution)\nSystem has infinite solutions\n\n\n\n\nEigenvectors and Eigenvalues\nEigenvectors and eigenvalues are fundamental concepts in linear algebra that reveal the intrinsic properties of linear transformations. They are crucial for understanding how matrices act on vectors and have profound applications in data science, particularly in dimensionality reduction, principal component analysis (PCA), and machine learning.\nMathematical Definition:\nFor a square matrix \\(A\\), an eigenvector \\(\\vec{v}\\) is a non-zero vector that, when multiplied by \\(A\\), results in a scalar multiple of itself:\n\\[A\\vec{v} = \\lambda\\vec{v}\\]\nWhere: - \\(\\vec{v}\\) is the eigenvector (direction that doesn’t change) - \\(\\lambda\\) (lambda) is the eigenvalue (scaling factor) - \\(A\\) is the square matrix\nGeometric Interpretation:\nWhen a matrix transforms a vector, most vectors change both direction and magnitude. However, eigenvectors are special - they only change in magnitude (scaled by the eigenvalue) but maintain their direction. Think of it as finding the “natural” directions of a transformation.\nKey Properties: - A matrix can have multiple eigenvector-eigenvalue pairs - Eigenvectors corresponding to different eigenvalues are orthogonal - The eigenvalues tell us how much the matrix stretches or shrinks in each eigenvector direction - If eigenvalue λ &gt; 1: stretching, if 0 &lt; λ &lt; 1: shrinking, if λ &lt; 0: reflection\nApplications in Data Science: - Principal Component Analysis (PCA): Finding directions of maximum variance - Dimensionality Reduction: Identifying most important features - Google PageRank: Ranking web pages using eigenvectors - Image Compression: Using eigenfaces for face recognition - Stability Analysis: Determining system behavior in dynamic models - Spectral Clustering: Graph-based clustering algorithms\n\n\nCode\n# Basic example: Finding eigenvalues and eigenvectors\nA = np.array([[3, 1],\n              [0, 2]])\n\n# Calculate eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(A)\n\nprint(\"Matrix A:\")\nprint(A)\nprint(f\"\\nEigenvalues: {eigenvalues}\")\nprint(f\"Eigenvectors:\\n{eigenvectors}\")\n\n# Verify the eigenvalue equation: Av = λv\nfor i in range(len(eigenvalues)):\n    v = eigenvectors[:, i]  # i-th eigenvector\n    lambda_val = eigenvalues[i]  # i-th eigenvalue\n    \n    Av = A @ v\n    lambda_v = lambda_val * v\n    \n    print(f\"\\nEigenvector {i+1}: {v}\")\n    print(f\"A * v = {Av}\")\n    print(f\"λ * v = {lambda_v}\")\n    print(f\"Are they equal? {np.allclose(Av, lambda_v)}\")\n\n\nMatrix A:\n[[3 1]\n [0 2]]\n\nEigenvalues: [3. 2.]\nEigenvectors:\n[[ 1.         -0.70710678]\n [ 0.          0.70710678]]\n\nEigenvector 1: [1. 0.]\nA * v = [3. 0.]\nλ * v = [3. 0.]\nAre they equal? True\n\nEigenvector 2: [-0.70710678  0.70710678]\nA * v = [-1.41421356  1.41421356]\nλ * v = [-1.41421356  1.41421356]\nAre they equal? True\n\n\n\n\nCode\n# Symmetric matrix example (real eigenvalues, orthogonal eigenvectors)\nS = np.array([[4, 2],\n              [2, 3]])\n\neigenvals_s, eigenvecs_s = np.linalg.eig(S)\n\nprint(\"Symmetric Matrix S:\")\nprint(S)\nprint(f\"Eigenvalues: {eigenvals_s}\")\nprint(f\"Eigenvectors:\\n{eigenvecs_s}\")\n\n# Check orthogonality of eigenvectors\ndot_product = np.dot(eigenvecs_s[:, 0], eigenvecs_s[:, 1])\nprint(f\"\\nDot product of eigenvectors: {dot_product:.10f}\")\nprint(f\"Eigenvectors are orthogonal: {abs(dot_product) &lt; 1e-10}\")\n\n\nSymmetric Matrix S:\n[[4 2]\n [2 3]]\nEigenvalues: [5.56155281 1.43844719]\nEigenvectors:\n[[ 0.78820544 -0.61541221]\n [ 0.61541221  0.78820544]]\n\nDot product of eigenvectors: 0.0000000000\nEigenvectors are orthogonal: True\n\n\n\n\nCode\n# 3D example\nA_3d = np.array([[6, -2, 2],\n                 [-2, 3, -1],\n                 [2, -1, 3]])\n\neigenvals_3d, eigenvecs_3d = np.linalg.eig(A_3d)\n\nprint(\"3D Matrix:\")\nprint(A_3d)\nprint(f\"\\nEigenvalues: {eigenvals_3d}\")\nprint(f\"\\nEigenvectors:\")\nfor i in range(len(eigenvals_3d)):\n    print(f\"λ{i+1} = {eigenvals_3d[i]:.3f}, v{i+1} = {eigenvecs_3d[:, i]}\")\n\n\n3D Matrix:\n[[ 6 -2  2]\n [-2  3 -1]\n [ 2 -1  3]]\n\nEigenvalues: [8. 2. 2.]\n\nEigenvectors:\nλ1 = 8.000, v1 = [ 0.81649658 -0.40824829  0.40824829]\nλ2 = 2.000, v2 = [-0.57735027 -0.57735027  0.57735027]\nλ3 = 2.000, v3 = [-0.11547005  0.57735027  0.80829038]\n\n\n\n\nCode\n# Practical example: Principal Component Analysis (PCA) basics\nnp.random.seed(42)\n\n# Generate correlated 2D data\nn_samples = 100\nx1 = np.random.normal(0, 2, n_samples)\nx2 = 1.5 * x1 + np.random.normal(0, 1, n_samples)\ndata = np.column_stack([x1, x2])\n\nprint(\"Original data shape:\", data.shape)\n\n# Center the data\ndata_centered = data - np.mean(data, axis=0)\n\n# Calculate covariance matrix\ncov_matrix = np.cov(data_centered.T)\nprint(\"Covariance Matrix:\")\nprint(cov_matrix)\n\n# Find principal components (eigenvectors of covariance matrix)\neigenvals_pca, eigenvecs_pca = np.linalg.eig(cov_matrix)\n\n# Sort by eigenvalue (descending order)\nidx = np.argsort(eigenvals_pca)[::-1]\neigenvals_pca = eigenvals_pca[idx]\neigenvecs_pca = eigenvecs_pca[:, idx]\n\nprint(f\"\\nPrincipal Component eigenvalues: {eigenvals_pca}\")\nprint(f\"Principal Component eigenvectors:\\n{eigenvecs_pca}\")\n\n# The first eigenvector is the direction of maximum variance\nprint(f\"\\nFirst PC explains {eigenvals_pca[0]/(eigenvals_pca[0]+eigenvals_pca[1])*100:.1f}% of variance\")\nprint(f\"Second PC explains {eigenvals_pca[1]/(eigenvals_pca[0]+eigenvals_pca[1])*100:.1f}% of variance\")\n\n\nOriginal data shape: (100, 2)\nCovariance Matrix:\n[[3.29907957 4.71231098]\n [4.71231098 7.62348838]]\n\nPrincipal Component eigenvalues: [10.64597323  0.27659473]\nPrincipal Component eigenvectors:\n[[-0.53989052 -0.84173525]\n [-0.84173525  0.53989052]]\n\nFirst PC explains 97.5% of variance\nSecond PC explains 2.5% of variance\n\n\n\n\nFor Further Exploration\n\n3Blue1Brown’s Linear Algebra Series provides intuitive visual explanations of linear algebra concepts, including eigenvectors and eigenvalues.\n\n\n\n\n1.2.3 Probability and Statistics\nProbability and statistics form the mathematical foundation of data science. While probability helps us model uncertainty and make predictions about future events, statistics provides tools to analyze data, test hypotheses, and draw meaningful conclusions. These concepts are essential for exploratory data analysis, hypothesis testing, and building robust machine learning models.\nKey Areas We’ll Cover: - Basic probability concepts and distributions - Descriptive statistics and data summarization - Statistical inference and hypothesis testing - Bayes’ theorem and its applications - Correlation and causation - Statistical distributions commonly used in data science\nUnderstanding these concepts is crucial for: - Exploratory Data Analysis (EDA): Summarizing and visualizing data patterns - Statistical Inference: Making conclusions about populations from samples - Machine Learning: Understanding model assumptions and uncertainty - Risk Assessment: Quantifying uncertainty in business decisions\n\nBasic Probability Concepts\nProbability is a measure of the likelihood that an event will occur, expressed as a number between 0 and 1, where: - 0 means the event is impossible - 1 means the event is certain - 0.5 means the event has equal chances of occurring or not\nKey Definitions:\nSample Space (S): The set of all possible outcomes of an experiment - Rolling a dice: S = \\(\\{1, 2, 3, 4, 5, 6\\}\\) - Flipping a coin: S = \\(\\{Heads, Tails\\}\\)\nEvent (E): A subset of the sample space - Rolling an even number: E = \\(\\{2, 4, 6\\}\\) - Getting heads: E = \\(\\{Heads\\}\\)\nProbability of an Event: P(E) = (Number of favorable outcomes) / (Total number of possible outcomes)\nFundamental Rules: 1. Addition Rule: P(A ∪ B) = P(A) + P(B) - P(A ∩ B) 2. Multiplication Rule: P(A ∩ B) = P(A) × P(B|A) 3. Complement Rule: P(A’) = 1 - P(A)\nConditional Probability: P(A|B) = P(A ∩ B) / P(B) The probability of event A given that event B has occurred.\nIndependence: Two events A and B are independent if P(A|B) = P(A) Or equivalently: P(A ∩ B) = P(A) × P(B)\n\n\nCode\nimport pandas as pd\nimport seaborn as sns\nfrom scipy import stats\n\n# Set style for better visualizations\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\n# Basic probability examples\nnp.random.seed(42)\n\n# Simulate coin flips\nn_flips = 1000\ncoin_flips = np.random.choice(['Heads', 'Tails'], n_flips, p=[0.5, 0.5])\n\n# Calculate probabilities\nheads_count = np.sum(coin_flips == 'Heads')\nprob_heads = heads_count / n_flips\n\nprint(\"Coin Flip Simulation:\")\nprint(f\"Number of flips: {n_flips}\")\nprint(f\"Heads: {heads_count}\")\nprint(f\"Tails: {n_flips - heads_count}\")\nprint(f\"Probability of Heads: {prob_heads:.3f}\")\nprint(f\"Expected Probability: 0.500\")\n\n# Visualize convergence to true probability\ncumulative_prob = np.cumsum(coin_flips == 'Heads') / np.arange(1, n_flips + 1)\n\nplt.figure(figsize=(10, 6))\nplt.plot(cumulative_prob, linewidth=2, label='Observed Probability')\nplt.axhline(y=0.5, color='red', linestyle='--', label='True Probability (0.5)')\nplt.xlabel('Number of Flips')\nplt.ylabel('Probability of Heads')\nplt.title('Law of Large Numbers: Coin Flip Convergence')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.savefig('im/probability_convergence.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n\nCoin Flip Simulation:\nNumber of flips: 1000\nHeads: 503\nTails: 497\nProbability of Heads: 0.503\nExpected Probability: 0.500\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Dice rolling example - multiple events\nn_rolls = 10000\ndice_rolls = np.random.randint(1, 7, n_rolls)\n\n# Calculate various probabilities\nprob_even = np.sum(dice_rolls % 2 == 0) / n_rolls\nprob_greater_4 = np.sum(dice_rolls &gt; 4) / n_rolls\nprob_1_or_6 = np.sum((dice_rolls == 1) | (dice_rolls == 6)) / n_rolls\n\nprint(\"Dice Rolling Simulation:\")\nprint(f\"Number of rolls: {n_rolls}\")\nprint(f\"P(Even number): {prob_even:.3f} (Expected: 0.500)\")\nprint(f\"P(&gt; 4): {prob_greater_4:.3f} (Expected: 0.333)\")\nprint(f\"P(1 or 6): {prob_1_or_6:.3f} (Expected: 0.333)\")\n\n# Visualize dice roll distribution\nplt.figure(figsize=(12, 5))\n\nplt.subplot(1, 2, 1)\nvalues, counts = np.unique(dice_rolls, return_counts=True)\nplt.bar(values, counts/n_rolls, alpha=0.7, color='skyblue')\nplt.axhline(y=1/6, color='red', linestyle='--', label='Expected Probability (1/6)')\nplt.xlabel('Dice Value')\nplt.ylabel('Probability')\nplt.title('Dice Roll Distribution')\nplt.legend()\nplt.grid(True, alpha=0.3)\n\nplt.subplot(1, 2, 2)\ntwo_dice = []\nfor i in range(1, 7):\n    for j in range(1, 7):\n        two_dice.append(i + j)\n\nplt.hist(two_dice, bins=range(2, 14), density=True, alpha=0.7, color='lightgreen', edgecolor='black')\nplt.xlabel('Sum of Two Dice')\nplt.ylabel('Probability')\nplt.title('Sum of Two Dice Distribution')\nplt.xticks(range(2, 13))\nplt.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('im/dice_probability.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n# Calculate P(sum = 7)\nsum_7_count = len([x for x in two_dice if x == 7])\nprob_sum_7 = sum_7_count / len(two_dice)\nprint(f\"\\nP(Sum = 7 with two dice): {prob_sum_7:.3f}\")\n\n\nDice Rolling Simulation:\nNumber of rolls: 10000\nP(Even number): 0.501 (Expected: 0.500)\nP(&gt; 4): 0.333 (Expected: 0.333)\nP(1 or 6): 0.334 (Expected: 0.333)\n\n\n\n\n\n\n\n\n\n\nP(Sum = 7 with two dice): 0.167\n\n\n\n\nDescriptive Statistics\nDescriptive statistics help us summarize and understand the main characteristics of a dataset. They provide insight into the center, spread, and shape of data distributions.\nMeasures of Central Tendency:\nMean (μ or x̄): The arithmetic average \\[\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i\\]\nMedian: The middle value when data is ordered - Robust to outliers - Better than mean for skewed distributions\nMode: The most frequently occurring value(s)\nMeasures of Dispersion:\nVariance (σ² or s²): Average of squared differences from the mean \\[\\sigma^2 = \\frac{1}{n}\\sum_{i=1}^{n} (x_i - \\mu)^2\\]\nStandard Deviation (σ or s): Square root of variance \\[\\sigma = \\sqrt{\\sigma^2}\\]\nRange: Difference between maximum and minimum values\nInterquartile Range (IQR): Difference between 75th and 25th percentiles - Q3 - Q1 - Measures spread of middle 50% of data\nMeasures of Shape:\nSkewness: Measure of asymmetry - Positive skew: tail extends to the right - Negative skew: tail extends to the left\nKurtosis: Measure of tail heaviness - High kurtosis: heavy tails, more outliers - Low kurtosis: light tails, fewer outliers\n\n\nCode\n# Generate sample datasets for statistical analysis\nnp.random.seed(42)\n\n# Create different types of distributions\nnormal_data = np.random.normal(100, 15, 1000)  # Mean=100, std=15\nskewed_data = np.random.exponential(2, 1000)   # Exponential distribution\nuniform_data = np.random.uniform(0, 100, 1000) # Uniform distribution\n\n# Create a DataFrame\ndf = pd.DataFrame({\n    'Normal': normal_data,\n    'Skewed': skewed_data,\n    'Uniform': uniform_data\n})\n\nprint(\"Descriptive Statistics Summary:\")\nprint(\"=\" * 50)\nprint(df.describe())\n\n# Calculate additional statistics\nprint(\"\\nAdditional Statistics:\")\nprint(\"=\" * 30)\nfor col in df.columns:\n    data = df[col]\n    print(f\"\\n{col} Distribution:\")\n    print(f\"  Median: {np.median(data):.2f}\")\n    print(f\"  Mode: {stats.mode(data)[0]:.2f}\")\n    print(f\"  Variance: {np.var(data, ddof=1):.2f}\")\n    print(f\"  Skewness: {stats.skew(data):.2f}\")\n    print(f\"  Kurtosis: {stats.kurtosis(data):.2f}\")\n    print(f\"  IQR: {np.percentile(data, 75) - np.percentile(data, 25):.2f}\")\n\n\nDescriptive Statistics Summary:\n==================================================\n            Normal       Skewed      Uniform\ncount  1000.000000  1000.000000  1000.000000\nmean    100.289981     2.015972    49.449499\nstd      14.688239     2.005977    28.891967\nmin      51.380990     0.006447     0.001163\n25%      90.286145     0.567909    25.652351\n50%     100.379509     1.451862    49.171060\n75%     109.719158     2.743369    73.862888\nmax     157.790972    14.883446    99.782086\n\nAdditional Statistics:\n==============================\n\nNormal Distribution:\n  Median: 100.38\n  Mode: 51.38\n  Variance: 215.74\n  Skewness: 0.12\n  Kurtosis: 0.07\n  IQR: 19.43\n\nSkewed Distribution:\n  Median: 1.45\n  Mode: 0.01\n  Variance: 4.02\n  Skewness: 1.98\n  Kurtosis: 5.38\n  IQR: 2.18\n\nUniform Distribution:\n  Median: 49.17\n  Mode: 0.00\n  Variance: 834.75\n  Skewness: 0.01\n  Kurtosis: -1.18\n  IQR: 48.21\n\n\n\n\nCode\n# Visualize distributions and their statistics\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\n\n# Row 1: Histograms\nfor i, col in enumerate(df.columns):\n    axes[0, i].hist(df[col], bins=50, density=True, alpha=0.7, color=f'C{i}')\n    axes[0, i].axvline(df[col].mean(), color='red', linestyle='--', \n                      linewidth=2, label=f'Mean: {df[col].mean():.1f}')\n    axes[0, i].axvline(df[col].median(), color='green', linestyle='--', \n                      linewidth=2, label=f'Median: {df[col].median():.1f}')\n    axes[0, i].set_title(f'{col} Distribution')\n    axes[0, i].set_xlabel('Value')\n    axes[0, i].set_ylabel('Density')\n    axes[0, i].legend()\n    axes[0, i].grid(True, alpha=0.3)\n\n# Row 2: Box plots\nfor i, col in enumerate(df.columns):\n    axes[1, i].boxplot(df[col])\n    axes[1, i].set_title(f'{col} Box Plot')\n    axes[1, i].set_ylabel('Value')\n    axes[1, i].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('im/descriptive_stats_distributions.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nStatistical Distributions\nStatistical distributions are mathematical functions that describe the probability of different outcomes in a dataset. Understanding common distributions is crucial for data analysis and modeling.\nNormal Distribution (Gaussian) - Bell-shaped, symmetric distribution - Defined by mean (μ) and standard deviation (σ) - 68-95-99.7 rule (empirical rule) - Many natural phenomena follow normal distribution\nProperties: - Mean = Median = Mode - 68% of data within 1σ of mean - 95% of data within 2σ of mean\n- 99.7% of data within 3σ of mean\nOther Important Distributions:\n\nUniform Distribution: All outcomes equally likely\nExponential Distribution: Models time between events\nPoisson Distribution: Models count of events in fixed intervals\nBinomial Distribution: Models number of successes in n trials\nChi-square Distribution: Used in hypothesis testing\nt-Distribution: Used when sample size is small\n\n\n\nCode\n# Demonstrate various statistical distributions\nfig, axes = plt.subplots(3, 3, figsize=(15, 12))\nfig.suptitle('Common Statistical Distributions', fontsize=16)\n\n# 1. Normal Distribution\nx = np.linspace(-4, 4, 100)\nnormal_pdf = stats.norm.pdf(x, 0, 1)\naxes[0, 0].plot(x, normal_pdf, 'b-', linewidth=2, label='μ=0, σ=1')\naxes[0, 0].fill_between(x, normal_pdf, alpha=0.3)\naxes[0, 0].set_title('Normal Distribution')\naxes[0, 0].set_xlabel('Value')\naxes[0, 0].set_ylabel('Probability Density')\naxes[0, 0].legend()\naxes[0, 0].grid(True, alpha=0.3)\n\n# 2. Uniform Distribution\nx_uniform = np.linspace(-0.5, 3.5, 100)\nuniform_pdf = stats.uniform.pdf(x_uniform, 0, 3)\naxes[0, 1].plot(x_uniform, uniform_pdf, 'r-', linewidth=2, label='a=0, b=3')\naxes[0, 1].fill_between(x_uniform, uniform_pdf, alpha=0.3)\naxes[0, 1].set_title('Uniform Distribution')\naxes[0, 1].set_xlabel('Value')\naxes[0, 1].set_ylabel('Probability Density')\naxes[0, 1].legend()\naxes[0, 1].grid(True, alpha=0.3)\n\n# 3. Exponential Distribution\nx_exp = np.linspace(0, 5, 100)\nexp_pdf = stats.expon.pdf(x_exp, scale=1)\naxes[0, 2].plot(x_exp, exp_pdf, 'g-', linewidth=2, label='λ=1')\naxes[0, 2].fill_between(x_exp, exp_pdf, alpha=0.3)\naxes[0, 2].set_title('Exponential Distribution')\naxes[0, 2].set_xlabel('Value')\naxes[0, 2].set_ylabel('Probability Density')\naxes[0, 2].legend()\naxes[0, 2].grid(True, alpha=0.3)\n\n# 4. Poisson Distribution\nx_poisson = np.arange(0, 15)\npoisson_pmf = stats.poisson.pmf(x_poisson, mu=3)\naxes[1, 0].bar(x_poisson, poisson_pmf, alpha=0.7, color='purple', label='λ=3')\naxes[1, 0].set_title('Poisson Distribution')\naxes[1, 0].set_xlabel('Number of Events')\naxes[1, 0].set_ylabel('Probability Mass')\naxes[1, 0].legend()\naxes[1, 0].grid(True, alpha=0.3)\n\n# 5. Binomial Distribution\nx_binomial = np.arange(0, 21)\nbinomial_pmf = stats.binom.pmf(x_binomial, n=20, p=0.3)\naxes[1, 1].bar(x_binomial, binomial_pmf, alpha=0.7, color='orange', label='n=20, p=0.3')\naxes[1, 1].set_title('Binomial Distribution')\naxes[1, 1].set_xlabel('Number of Successes')\naxes[1, 1].set_ylabel('Probability Mass')\naxes[1, 1].legend()\naxes[1, 1].grid(True, alpha=0.3)\n\n# 6. Chi-square Distribution\nx_chi2 = np.linspace(0, 15, 100)\nchi2_pdf = stats.chi2.pdf(x_chi2, df=4)\naxes[1, 2].plot(x_chi2, chi2_pdf, 'brown', linewidth=2, label='df=4')\naxes[1, 2].fill_between(x_chi2, chi2_pdf, alpha=0.3)\naxes[1, 2].set_title('Chi-square Distribution')\naxes[1, 2].set_xlabel('Value')\naxes[1, 2].set_ylabel('Probability Density')\naxes[1, 2].legend()\naxes[1, 2].grid(True, alpha=0.3)\n\n# 7. t-Distribution\nx_t = np.linspace(-4, 4, 100)\nt_pdf = stats.t.pdf(x_t, df=5)\nnormal_pdf_comp = stats.norm.pdf(x_t, 0, 1)\naxes[2, 0].plot(x_t, t_pdf, 'red', linewidth=2, label='t-dist (df=5)')\naxes[2, 0].plot(x_t, normal_pdf_comp, 'blue', linewidth=2, linestyle='--', label='Normal')\naxes[2, 0].set_title('t-Distribution vs Normal')\naxes[2, 0].set_xlabel('Value')\naxes[2, 0].set_ylabel('Probability Density')\naxes[2, 0].legend()\naxes[2, 0].grid(True, alpha=0.3)\n\n# 8. Beta Distribution\nx_beta = np.linspace(0, 1, 100)\nbeta_pdf = stats.beta.pdf(x_beta, a=2, b=5)\naxes[2, 1].plot(x_beta, beta_pdf, 'pink', linewidth=2, label='α=2, β=5')\naxes[2, 1].fill_between(x_beta, beta_pdf, alpha=0.3)\naxes[2, 1].set_title('Beta Distribution')\naxes[2, 1].set_xlabel('Value')\naxes[2, 1].set_ylabel('Probability Density')\naxes[2, 1].legend()\naxes[2, 1].grid(True, alpha=0.3)\n\n# 9. Gamma Distribution\nx_gamma = np.linspace(0, 10, 100)\ngamma_pdf = stats.gamma.pdf(x_gamma, a=2, scale=1)\naxes[2, 2].plot(x_gamma, gamma_pdf, 'cyan', linewidth=2, label='α=2, β=1')\naxes[2, 2].fill_between(x_gamma, gamma_pdf, alpha=0.3)\naxes[2, 2].set_title('Gamma Distribution')\naxes[2, 2].set_xlabel('Value')\naxes[2, 2].set_ylabel('Probability Density')\naxes[2, 2].legend()\naxes[2, 2].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('im/statistical_distributions.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Real-world applications of distributions with simulated data\nprint(\"Distribution Applications in Data Science:\")\nprint(\"=\" * 50)\n\n# 1. Normal Distribution - Height data\nheights = np.random.normal(170, 10, 1000)  # Heights in cm\nprint(f\"Height Data (Normal Distribution):\")\nprint(f\"  Mean height: {np.mean(heights):.1f} cm\")\nprint(f\"  Std deviation: {np.std(heights):.1f} cm\")\nprint(f\"  % between 160-180 cm: {np.sum((heights &gt;= 160) & (heights &lt;= 180))/len(heights)*100:.1f}%\")\n\n# 2. Exponential Distribution - Time between customer arrivals\narrival_times = np.random.exponential(5, 1000)  # Average 5 minutes between arrivals\nprint(f\"\\nCustomer Arrival Times (Exponential Distribution):\")\nprint(f\"  Average time between arrivals: {np.mean(arrival_times):.1f} minutes\")\nprint(f\"  % of arrivals within 2 minutes: {np.sum(arrival_times &lt;= 2)/len(arrival_times)*100:.1f}%\")\n\n# 3. Poisson Distribution - Number of website visits per hour\nvisits_per_hour = np.random.poisson(50, 24*7)  # 50 average visits per hour for a week\nprint(f\"\\nWebsite Visits (Poisson Distribution):\")\nprint(f\"  Average visits per hour: {np.mean(visits_per_hour):.1f}\")\nprint(f\"  Max visits in an hour: {np.max(visits_per_hour)}\")\nprint(f\"  Hours with &gt;60 visits: {np.sum(visits_per_hour &gt; 60)}\")\n\n# 4. Binomial Distribution - A/B Testing\n# 100 users, 15% conversion rate\nconversions = np.random.binomial(100, 0.15, 1000)  # 1000 experiments\nprint(f\"\\nA/B Test Conversions (Binomial Distribution):\")\nprint(f\"  Average conversions per 100 users: {np.mean(conversions):.1f}\")\nprint(f\"  95% confidence interval: [{np.percentile(conversions, 2.5):.0f}, {np.percentile(conversions, 97.5):.0f}]\")\n\n# Visualize these applications\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# Heights\naxes[0, 0].hist(heights, bins=50, density=True, alpha=0.7, color='skyblue')\nx_heights = np.linspace(heights.min(), heights.max(), 100)\naxes[0, 0].plot(x_heights, stats.norm.pdf(x_heights, np.mean(heights), np.std(heights)), \n                'r-', linewidth=2, label='Normal Fit')\naxes[0, 0].set_title('Heights Distribution')\naxes[0, 0].set_xlabel('Height (cm)')\naxes[0, 0].set_ylabel('Density')\naxes[0, 0].legend()\naxes[0, 0].grid(True, alpha=0.3)\n\n# Arrival times\naxes[0, 1].hist(arrival_times, bins=50, density=True, alpha=0.7, color='lightgreen')\nx_arrivals = np.linspace(0, arrival_times.max(), 100)\naxes[0, 1].plot(x_arrivals, stats.expon.pdf(x_arrivals, scale=np.mean(arrival_times)), \n                'r-', linewidth=2, label='Exponential Fit')\naxes[0, 1].set_title('Time Between Customer Arrivals')\naxes[0, 1].set_xlabel('Time (minutes)')\naxes[0, 1].set_ylabel('Density')\naxes[0, 1].legend()\naxes[0, 1].grid(True, alpha=0.3)\n\n# Website visits\nx_visits = np.arange(0, visits_per_hour.max()+1)\naxes[1, 0].hist(visits_per_hour, bins=30, density=True, alpha=0.7, color='lightcoral')\naxes[1, 0].plot(x_visits, stats.poisson.pmf(x_visits, np.mean(visits_per_hour)), \n                'ro-', linewidth=2, markersize=4, label='Poisson Fit')\naxes[1, 0].set_title('Website Visits per Hour')\naxes[1, 0].set_xlabel('Number of Visits')\naxes[1, 0].set_ylabel('Density')\naxes[1, 0].legend()\naxes[1, 0].grid(True, alpha=0.3)\n\n# Conversions\nx_conv = np.arange(0, conversions.max()+1)\naxes[1, 1].hist(conversions, bins=20, density=True, alpha=0.7, color='gold')\naxes[1, 1].plot(x_conv, stats.binom.pmf(x_conv, 100, np.mean(conversions)/100), \n                'ro-', linewidth=2, markersize=3, label='Binomial Fit')\naxes[1, 1].set_title('A/B Test Conversions')\naxes[1, 1].set_xlabel('Number of Conversions')\naxes[1, 1].set_ylabel('Density')\naxes[1, 1].legend()\naxes[1, 1].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('im/distribution_applications.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n\nDistribution Applications in Data Science:\n==================================================\nHeight Data (Normal Distribution):\n  Mean height: 170.1 cm\n  Std deviation: 10.3 cm\n  % between 160-180 cm: 65.7%\n\nCustomer Arrival Times (Exponential Distribution):\n  Average time between arrivals: 5.0 minutes\n  % of arrivals within 2 minutes: 33.4%\n\nWebsite Visits (Poisson Distribution):\n  Average visits per hour: 50.7\n  Max visits in an hour: 75\n  Hours with &gt;60 visits: 14\n\nA/B Test Conversions (Binomial Distribution):\n  Average conversions per 100 users: 14.9\n  95% confidence interval: [9, 22]\n\n\n\n\n\n\n\n\n\n\n\nBayes’ Theorem\nBayes’ theorem is a fundamental principle in probability theory that describes how to update the probability of a hypothesis based on new evidence. It’s the foundation of Bayesian statistics and has numerous applications in machine learning, medical diagnosis, spam filtering, and decision-making.\nMathematical Formula:\n\\[P(A|B) = \\frac{P(B|A) \\times P(A)}{P(B)}\\]\nWhere: - P(A|B): Posterior probability - probability of A given B - P(B|A): Likelihood - probability of B given A\n- P(A): Prior probability - initial probability of A - P(B): Marginal probability - total probability of B\nIn words: Posterior = (Likelihood × Prior) / Evidence\nKey Components:\n\nPrior P(A): Our initial belief about the probability of A before seeing evidence\nLikelihood P(B|A): How likely we are to observe evidence B if A is true\nEvidence P(B): Total probability of observing evidence B\nPosterior P(A|B): Updated probability of A after observing evidence B\n\nApplications in Data Science: - Medical Diagnosis: Update disease probability based on test results - Spam Detection: Classify emails based on word patterns - Machine Learning: Naive Bayes classifier\n\n\nCode\n# Bayes' Theorem Examples\n\nprint(\"Bayes' Theorem Applications\")\nprint(\"=\" * 40)\n\n# Example 1: Medical Diagnosis\nprint(\"Example 1: Medical Diagnosis\")\nprint(\"-\" * 30)\n\n# Disease affects 1% of population\nprior_disease = 0.01\nprior_no_disease = 1 - prior_disease\n\n# Test accuracy: 95% sensitivity, 90% specificity\nsensitivity = 0.95  # P(Test+ | Disease)\nspecificity = 0.90  # P(Test- | No Disease)\nfalse_positive_rate = 1 - specificity  # P(Test+ | No Disease)\n\n# Evidence: P(Test+)\nevidence_test_positive = (sensitivity * prior_disease) + (false_positive_rate * prior_no_disease)\n\n# Posterior: P(Disease | Test+)\nposterior_disease_given_positive = (sensitivity * prior_disease) / evidence_test_positive\n\nprint(f\"Prior probability of disease: {prior_disease:.1%}\")\nprint(f\"Test sensitivity: {sensitivity:.1%}\")\nprint(f\"Test specificity: {specificity:.1%}\")\nprint(f\"Probability of positive test: {evidence_test_positive:.1%}\")\nprint(f\"Probability of disease given positive test: {posterior_disease_given_positive:.1%}\")\n\n# Example 2: Spam Detection\nprint(f\"\\nExample 2: Spam Detection\")\nprint(\"-\" * 30)\n\n# Prior probabilities\nprior_spam = 0.3  # 30% of emails are spam\nprior_ham = 0.7   # 70% of emails are legitimate\n\n# Likelihood of word \"free\" appearing\nlikelihood_free_given_spam = 0.8   # 80% of spam contains \"free\"\nlikelihood_free_given_ham = 0.1    # 10% of legitimate emails contain \"free\"\n\n# Evidence: P(\"free\")\nevidence_free = (likelihood_free_given_spam * prior_spam) + (likelihood_free_given_ham * prior_ham)\n\n# Posterior: P(Spam | \"free\")\nposterior_spam_given_free = (likelihood_free_given_spam * prior_spam) / evidence_free\n\nprint(f\"Prior probability of spam: {prior_spam:.1%}\")\nprint(f\"P('free' | spam): {likelihood_free_given_spam:.1%}\")\nprint(f\"P('free' | legitimate): {likelihood_free_given_ham:.1%}\")\nprint(f\"P(spam | 'free'): {posterior_spam_given_free:.1%}\")\n\n\nBayes' Theorem Applications\n========================================\nExample 1: Medical Diagnosis\n------------------------------\nPrior probability of disease: 1.0%\nTest sensitivity: 95.0%\nTest specificity: 90.0%\nProbability of positive test: 10.8%\nProbability of disease given positive test: 8.8%\n\nExample 2: Spam Detection\n------------------------------\nPrior probability of spam: 30.0%\nP('free' | spam): 80.0%\nP('free' | legitimate): 10.0%\nP(spam | 'free'): 77.4%\n\n\n\n\nCorrelation and Causation\nUnderstanding the relationship between variables is crucial in data analysis. Correlation measures the strength and direction of a linear relationship between two variables, while causation implies that one variable directly influences another.\nKey Principle: “Correlation does not imply causation”\nCorrelation Coefficient (Pearson’s r): \\[r = \\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^{n}(x_i - \\bar{x})^2 \\sum_{i=1}^{n}(y_i - \\bar{y})^2}}\\]\nInterpretation: - r = +1: Perfect positive correlation - r = 0: No linear correlation\n- r = -1: Perfect negative correlation - |r| &gt; 0.7: Strong correlation - 0.3 &lt; |r| &lt; 0.7: Moderate correlation - |r| &lt; 0.3: Weak correlation\nTypes of Relationships: 1. No relationship: Variables are independent 2. Linear relationship: Variables change at a constant rate 3. Non-linear relationship: Variables are related but not linearly 4. Spurious correlation: Variables appear related due to confounding factors\nEstablishing Causation: 1. Temporal precedence: Cause must precede effect 2. Covariation: Cause and effect must be correlated 3. Non-spuriousness: Relationship isn’t due to third variable 4. Mechanism: Logical explanation for how cause leads to effect\n\n\nCode\n# Generate data to demonstrate correlation vs causation\nnp.random.seed(42)\nn = 500\n\n# Example 1: Strong positive correlation\nx1 = np.random.normal(0, 1, n)\ny1 = 2 * x1 + np.random.normal(0, 0.5, n)  # y = 2x + noise\n\n# Example 2: No correlation\nx2 = np.random.normal(0, 1, n)\ny2 = np.random.normal(0, 1, n)  # Independent variables\n\n# Example 3: Non-linear relationship\nx3 = np.random.uniform(-3, 3, n)\ny3 = x3**2 + np.random.normal(0, 1, n)  # Quadratic relationship\n\n# Example 4: Spurious correlation (both depend on third variable)\nz = np.random.normal(0, 1, n)  # Hidden variable\nx4 = z + np.random.normal(0, 0.5, n)\ny4 = z + np.random.normal(0, 0.5, n)\n\n# Calculate correlation coefficients\ncorr1 = np.corrcoef(x1, y1)[0, 1]\ncorr2 = np.corrcoef(x2, y2)[0, 1]\ncorr3 = np.corrcoef(x3, y3)[0, 1]\ncorr4 = np.corrcoef(x4, y4)[0, 1]\n\nprint(\"Correlation Analysis Examples:\")\nprint(\"=\" * 40)\nprint(f\"1. Linear relationship: r = {corr1:.3f}\")\nprint(f\"2. No relationship: r = {corr2:.3f}\")\nprint(f\"3. Non-linear relationship: r = {corr3:.3f}\")\nprint(f\"4. Spurious correlation: r = {corr4:.3f}\")\n\n# Create comprehensive correlation visualization\nfig, axes = plt.subplots(2, 3, figsize=(18, 12))\nfig.suptitle('Correlation vs Causation Examples', fontsize=16)\n\n# Example 1: Strong positive correlation\naxes[0, 0].scatter(x1, y1, alpha=0.6, color='blue')\nz1 = np.polyfit(x1, y1, 1)\np1 = np.poly1d(z1)\naxes[0, 0].plot(x1, p1(x1), \"r--\", alpha=0.8, linewidth=2)\naxes[0, 0].set_title(f'Strong Positive Correlation\\nr = {corr1:.3f}')\naxes[0, 0].set_xlabel('X Variable')\naxes[0, 0].set_ylabel('Y Variable')\naxes[0, 0].grid(True, alpha=0.3)\n\n# Example 2: No correlation\naxes[0, 1].scatter(x2, y2, alpha=0.6, color='green')\naxes[0, 1].set_title(f'No Correlation\\nr = {corr2:.3f}')\naxes[0, 1].set_xlabel('X Variable')\naxes[0, 1].set_ylabel('Y Variable')\naxes[0, 1].grid(True, alpha=0.3)\n\n# Example 3: Non-linear relationship\naxes[0, 2].scatter(x3, y3, alpha=0.6, color='red')\n# Fit quadratic curve\nz3 = np.polyfit(x3, y3, 2)\np3 = np.poly1d(z3)\nx3_sorted = np.linspace(x3.min(), x3.max(), 100)\naxes[0, 2].plot(x3_sorted, p3(x3_sorted), \"orange\", linewidth=2, label='Quadratic fit')\naxes[0, 2].set_title(f'Non-linear Relationship\\nPearson r = {corr3:.3f}')\naxes[0, 2].set_xlabel('X Variable')\naxes[0, 2].set_ylabel('Y Variable')\naxes[0, 2].legend()\naxes[0, 2].grid(True, alpha=0.3)\n\n# Example 4: Spurious correlation\naxes[1, 0].scatter(x4, y4, alpha=0.6, color='purple')\nz4 = np.polyfit(x4, y4, 1)\np4 = np.poly1d(z4)\naxes[1, 0].plot(x4, p4(x4), \"orange\", alpha=0.8, linewidth=2)\naxes[1, 0].set_title(f'Spurious Correlation\\nr = {corr4:.3f}')\naxes[1, 0].set_xlabel('X Variable')\naxes[1, 0].set_ylabel('Y Variable')\naxes[1, 0].grid(True, alpha=0.3)\n\n# Create correlation heatmap for multiple variables\n# Real-world example: student performance data\nnp.random.seed(42)\nstudy_hours = np.random.gamma(2, 3, n)  # Hours studied per week\nsleep_hours = 8 - 0.1 * study_hours + np.random.normal(0, 1, n)  # Sleep affected by study\nsleep_hours = np.clip(sleep_hours, 4, 12)  # Reasonable sleep range\ntest_score = 50 + 2 * study_hours + 3 * sleep_hours + np.random.normal(0, 10, n)\ntest_score = np.clip(test_score, 0, 100)  # Score between 0-100\nstress_level = 100 - test_score + np.random.normal(0, 15, n)  # Stress inversely related to score\nstress_level = np.clip(stress_level, 0, 100)\n\n# Create DataFrame\nstudent_data = pd.DataFrame({\n    'Study_Hours': study_hours,\n    'Sleep_Hours': sleep_hours,\n    'Test_Score': test_score,\n    'Stress_Level': stress_level\n})\n\n# Correlation matrix\ncorr_matrix = student_data.corr()\nmask = np.triu(np.ones_like(corr_matrix, dtype=bool))\n\nsns.heatmap(corr_matrix, mask=mask, annot=True, cmap='RdBu_r', center=0,\n            square=True, ax=axes[1, 1], cbar_kws={\"shrink\": .8})\naxes[1, 1].set_title('Student Performance\\nCorrelation Matrix')\n\n# Pairplot equivalent using scatter plots\naxes[1, 2].scatter(student_data['Study_Hours'], student_data['Test_Score'], \n                  alpha=0.6, color='darkblue')\naxes[1, 2].set_title('Study Hours vs Test Score\\nCausal Relationship?')\naxes[1, 2].set_xlabel('Study Hours per Week')\naxes[1, 2].set_ylabel('Test Score')\naxes[1, 2].grid(True, alpha=0.3)\n\n# Add trend line\nz_study = np.polyfit(student_data['Study_Hours'], student_data['Test_Score'], 1)\np_study = np.poly1d(z_study)\naxes[1, 2].plot(student_data['Study_Hours'], p_study(student_data['Study_Hours']), \n               \"red\", alpha=0.8, linewidth=2)\n\nplt.tight_layout()\nplt.savefig('im/correlation_causation_analysis.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n# Print correlation analysis\nprint(f\"\\nStudent Performance Correlations:\")\nprint(\"-\" * 35)\nfor i, var1 in enumerate(student_data.columns):\n    for var2 in student_data.columns[i+1:]:\n        corr = student_data[var1].corr(student_data[var2])\n        print(f\"{var1} vs {var2}: r = {corr:.3f}\")\n\n\nCorrelation Analysis Examples:\n========================================\n1. Linear relationship: r = 0.969\n2. No relationship: r = -0.022\n3. Non-linear relationship: r = -0.021\n4. Spurious correlation: r = 0.820\n\n\n\n\n\n\n\n\n\n\nStudent Performance Correlations:\n-----------------------------------\nStudy_Hours vs Sleep_Hours: r = -0.323\nStudy_Hours vs Test_Score: r = 0.556\nStudy_Hours vs Stress_Level: r = -0.288\nSleep_Hours vs Test_Score: r = 0.005\nSleep_Hours vs Stress_Level: r = -0.008\nTest_Score vs Stress_Level: r = -0.600\n\n\n\n\nFor Further Exploration\nCheck out these resources to deepen your understanding of probability and statistics:\n\nNormal Distribution\nCorrelation\nBayes’ Theorem\nCentral Limit Theorem"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "SIAFI Data Science and Machine Learning Handbook\nWelcome! Use the navigation bar to explore topics: - Introduction to Data Science - Machine Learning - Deep Learning"
  }
]